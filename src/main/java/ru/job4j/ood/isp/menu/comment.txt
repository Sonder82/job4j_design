24.10.2022
Класс SimpleMenu.

Метод findItem и iterator делаем на основе итератора DFSIterator.
Iterator<ItemInfo> iterator = new DFSIterator();
Не мог понять как "подступиться" к методам. Пока не прочитал этого.

Изначально написал метод select вот так:
@Override
    public Optional<MenuItemInfo> select(String itemName) {
        Optional<ItemInfo> itemInfo = findItem(itemName);
        MenuItemInfo menuItemInfo = new MenuItemInfo(itemInfo.get().getMenuItem(), itemInfo.get().getNumber());
        return Optional.of(menuItemInfo);
    }
В вкладке Problems появилась подсказка, что могу получить NPE при таком коде.
Например если в itemName закинуть несуществующий Name.
Загуглив, эту проблему можно решить через метод map.
Результат помещается в новый Optional <MenuItemInfo>
Сделано. Получилось решение в одну строку!!!!

25.10.2022
Не смог понять как реализовать метод add. Написал ментору.
Долго не мог понять структуру. Сейчас вроде понял.
menu.add(Menu.ROOT, "Сходить в магазин", STUB_ACTION);
Menu.ROOT - это значит мы назначили пункт меню. Первый вызов,значит цифра 1.
Название этого пункта меню будет "Сходить в магазин".
Т.е. в этом примере "само Menu" это parent.
Child -ом будет пункт меню "Сходить в магазин" относительно parent.
menu.add("Сходить в магазин", "Купить продукты", STUB_ACTION);
"Сходить в магазин" - parent. Пункт 1
"Купить продукты" - child. Пункт 1.1
menu.add("Купить продукты", "Купить хлеб", STUB_ACTION);
"Купить продукты" - parent. Пункт 1.1
"Купить хлеб" - child. Пункт 1.1.1
Таким образом в Menu мы формируем каркас в виде дерева.
Узлы этого дерева "Купить продукты" или "Купить хлеб" будут объекты MenuItem.
Теперь можно вставить вот это пояснение из задания
На основе всего вышесказанного мы подходим к тому, что

- Строим дерево на основе MenuItem, но добавление делаем по независимым данным от MenuItem.
- Данные меню возвращаем в виде другого объекта. Например, MenuItemInfo.

Такая структура позволит быстро добавить пункт/подпункт меню. Например
menu.add("Сходить в магазин", "Купить одежду", STUB_ACTION);
menu.add("Купить одежду", "Купить рубашку", STUB_ACTION);
"Купить одежду" - parent. Пункт 1.2
"Купить рубашку" - child. Пункт 1.2.1

26.10.2022
В add в первую очередь нужно проверить childName на уникальность имени.
Если у нас в меню будут дублироваться элементы, то это затруднит их поиск,
так как в findItem мы найдем первое совпадение.

Дальше нужно сравнить parentName с null (используйте ROOT).
Если имя предка null, значит нужно добавить в корень, т.е сразу в rootElements.
Если не в корень, то нужно найти предка.
Используйте в методе во всех условиях ранний возврат.

27.10.2022
Приступил к MenuPrinter.
Необходимо вывести на печать Menu в виде иерархии.
Решил, что идентификацию иерархии можно сделать в нашем примере
через количество точек в номере пункта меню.
Чем меньше точек, тем старше пункт.
Для поиска точек решил разбить строку на символы и найти точки.
Использовал лямбду
.chars().filter(ch -> ch == '.').count();
Дальше с помощью полученного значения количества точек выстроил логику печати.
